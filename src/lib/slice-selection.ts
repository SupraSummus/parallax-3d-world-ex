/**
 * Slice Selection Module
 * 
 * This module implements a two-mechanism rendering system:
 * 
 * ## Mechanism 1: Camera-Independent World Slicing
 * 
 * The world is divided into fixed slices whose boundaries never change.
 * Each slice's size is determined by its STARTING DEPTH's alignment:
 * - A depth that is divisible by N (but not 2N) starts a slice of size N
 * - Slices are contiguous: one slice ends where the next begins
 * - The same z-coordinate is ALWAYS in the same slice, regardless of camera
 * 
 * Example world slices (fixed, camera-independent):
 * - [0, 64)  size 64 - because 0 % 64 == 0 and 0 is the "everything divides" case
 * - [64, 128) size 64 - because 64 % 64 == 0
 * - [-64, 0) size 64 - because -64 % 64 == 0
 * - [-66, -64) size 2 - because -66 % 2 == 0 but -66 % 4 != 0
 * 
 * ## Mechanism 2: Camera-Dependent Selection
 * 
 * The camera determines WHICH of these fixed slices are visible:
 * 1. Camera computes visible range: [cameraZ + minDepth, cameraZ + maxDepth]
 * 2. All world slices overlapping this range are selected for rendering
 * 
 * The slices themselves don't change - only which ones are visible.
 */

export interface SliceBoundary {
  /** The starting z-coordinate in world space (absolute, camera-independent) */
  depth: number
  /** The thickness of this slice in z-units */
  size: number
}

const MIN_SIZE = 1
const MAX_SIZE = 64
export const DEFAULT_DEPTH_MULTIPLIER = 2

// ============================================================================
// MECHANISM 1: Camera-Independent World Slicing
// ============================================================================

/**
 * Gets the largest valid size for the given depth multiplier.
 * Valid sizes are powers of the multiplier (1, m, m^2, ...) up to MAX_SIZE.
 */
function getMaxValidSize(depthMultiplier: number): number {
  let maxValid = MIN_SIZE
  let testSize = MIN_SIZE
  while (testSize <= MAX_SIZE) {
    maxValid = testSize
    const nextSize = Math.round(testSize * depthMultiplier)
    if (nextSize <= testSize) break
    testSize = nextSize
  }
  return maxValid
}

/**
 * Gets the canonical size for a slice starting at a given depth.
 * 
 * The size is the largest power of depthMultiplier that evenly divides the depth,
 * capped at the largest valid size. For depth=0, returns the largest valid size
 * since 0 is divisible by all.
 * 
 * This is a WORLD SLICING function - the result depends only on the depth,
 * not on any camera position.
 * 
 * @param depth - The starting z-coordinate of a slice
 * @param depthMultiplier - The geometric progression multiplier (default 2)
 * @returns The size of the slice starting at this depth
 */
function getSliceSizeForDepth(depth: number, depthMultiplier: number = DEFAULT_DEPTH_MULTIPLIER): number {
  const maxValidSize = getMaxValidSize(depthMultiplier)
  
  // For depth 0, any power divides it, so use max valid size
  if (depth === 0) {
    return maxValidSize
  }
  
  // Find the largest power of depthMultiplier that divides depth
  let size = MIN_SIZE
  let testSize = MIN_SIZE
  
  while (testSize <= MAX_SIZE) {
    if (depth % testSize === 0) {
      size = testSize
    }
    const nextSize = Math.round(testSize * depthMultiplier)
    if (nextSize <= testSize) break
    testSize = nextSize
  }
  
  return size
}

/**
 * Gets the canonical slice that contains a given z-coordinate.
 * 
 * This finds the unique world slice that contains z. The slice is determined
 * by finding which aligned slice boundary contains z, based on the sizes
 * that getSliceSizeForDepth would produce.
 * 
 * This is a WORLD SLICING function - the result is always the same for a given z,
 * regardless of camera position.
 * 
 * @param z - A z-coordinate in world space (can be fractional)
 * @param depthMultiplier - The geometric progression multiplier (default 2)
 * @returns The canonical slice boundary containing this z
 */
function getSliceContainingZ(z: number, depthMultiplier: number = DEFAULT_DEPTH_MULTIPLIER): SliceBoundary {
  const intZ = Math.floor(z)
  const maxValidSize = getMaxValidSize(depthMultiplier)
  
  // Special case: z in [0, maxValidSize) is in the slice starting at 0
  if (intZ >= 0 && intZ < maxValidSize) {
    return { depth: 0, size: maxValidSize }
  }
  
  // For negative z or z >= maxValidSize, we need to find the containing slice
  // Strategy: Try each valid size (generated by depthMultiplier) from largest to smallest,
  // compute the aligned depth, and check if it would produce this size and contain intZ
  
  // Build list of valid sizes
  const validSizes: number[] = []
  let testSize = MIN_SIZE
  while (testSize <= MAX_SIZE) {
    validSizes.push(testSize)
    const nextSize = Math.round(testSize * depthMultiplier)
    if (nextSize <= testSize) break
    testSize = nextSize
  }
  
  // Try sizes from largest to smallest
  for (let i = validSizes.length - 1; i >= 0; i--) {
    const size = validSizes[i]
    const alignedDepth = Math.floor(intZ / size) * size
    
    // Check if alignedDepth would have exactly this size
    const actualSize = getSliceSizeForDepth(alignedDepth, depthMultiplier)
    if (actualSize === size) {
      // Check if this slice contains intZ
      if (alignedDepth <= intZ && intZ < alignedDepth + size) {
        return { depth: alignedDepth, size }
      }
    }
  }
  
  // Fallback: size 1 slice (should not reach here)
  return { depth: intZ, size: MIN_SIZE }
}

// ============================================================================
// MECHANISM 2: Camera-Dependent Selection
// ============================================================================

/**
 * Generates all world slices that overlap with a given z range.
 * 
 * This iterates through the camera-independent world slices and returns
 * those that overlap with [minZ, maxZ).
 * 
 * @param minZ - Minimum z-coordinate (absolute world space)
 * @param maxZ - Maximum z-coordinate (absolute world space)
 * @param depthMultiplier - The geometric progression multiplier (default 2)
 * @returns Array of slice boundaries sorted by depth
 */
function generateSlicesForRange(minZ: number, maxZ: number, depthMultiplier: number = DEFAULT_DEPTH_MULTIPLIER): SliceBoundary[] {
  if (minZ >= maxZ) {
    return []
  }

  const slices: SliceBoundary[] = []
  
  // Find the canonical slice containing minZ
  let currentSlice = getSliceContainingZ(minZ, depthMultiplier)
  
  // Add slices until we cover maxZ
  while (currentSlice.depth < maxZ) {
    slices.push(currentSlice)
    
    // Move to the next slice starting at the end of this one
    const nextZ = currentSlice.depth + currentSlice.size
    if (nextZ >= maxZ) break
    
    currentSlice = getSliceContainingZ(nextZ, depthMultiplier)
    
    // Safety check to prevent infinite loops
    if (currentSlice.depth < nextZ) {
      currentSlice = { depth: nextZ, size: MIN_SIZE }
    }
  }

  return slices.sort((a, b) => a.depth - b.depth)
}

/**
 * Selects world slices that are visible from the camera's perspective.
 * 
 * This is the main CAMERA SELECTION function:
 * 1. Computes the visible range in absolute world coordinates
 * 2. Returns all world slices that overlap with the visible range
 * 
 * The world slices are camera-independent - this function only SELECTS
 * which ones are visible, it doesn't change their boundaries.
 * 
 * @param cameraZ - Camera z position in world space
 * @param minRelativeDepth - Minimum viewing depth (relative to camera)
 * @param maxRelativeDepth - Maximum viewing depth (relative to camera)
 * @param depthMultiplier - The geometric progression multiplier (default 2)
 * @returns Array of slice boundaries sorted by depth (in absolute world coordinates)
 */
export function selectSlices(cameraZ: number, minRelativeDepth: number, maxRelativeDepth: number, depthMultiplier: number = DEFAULT_DEPTH_MULTIPLIER): SliceBoundary[] {
  // Convert relative depths to absolute world z-coordinates
  const visibleMinZ = cameraZ + minRelativeDepth
  const visibleMaxZ = cameraZ + maxRelativeDepth
  
  // Select world slices that overlap with the visible range
  return generateSlicesForRange(visibleMinZ, visibleMaxZ, depthMultiplier)
}
